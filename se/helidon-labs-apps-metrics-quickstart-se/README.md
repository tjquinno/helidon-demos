# Helidon SE General Metrics Example

This example results from using `helidon init` to create a Helidon SE QuickStart example app, then applying a few simple changes to illustrate various aspects of metrics.

You can recreate the example by following the steps described below.

Note that an optional step shows an incubating feature in Helidon 4.x which includes Helidon-provided meters for virtual threads. To experiment with that feature you need Java 24 or later, so download and install JDK 24 now if you want to try that feature.
## Prerequisites
1. Download the Helidon CLI if you do not already have it. See the [CLI doc page](https://helidon.io/docs/v4/about/cli) for complete information.

   MacOS
   ```shell
   curl -L -O https://helidon.io/cli/latest/darwin/helidon
   chmod +x ./helidon
   sudo mv ./helidon /usr/local/bin/
   ```
2. If you want to use the incubating virtual threads metrics you need to download JDK 24 or later.  See the [Java downloads page](https://www.oracle.com/java/technologies/downloads/).
3. To use the Prometheus back-end and UI to browse metrics, [download Prometheus](https://prometheus.io/download/). The `prometheus.yml` config file in this project contains settings to retrieve metrics from the SE and MP variants of this application.

## Create the project
1. Copy the `.helidon` file from this project into a local directory on your system.
2. Create the example project using that file's settings with the following command.
   ```shell
   helidon init --props-file path-to-the-copied-.helidon-file
   ```
   This is equivalent to invoking `helidon init --version 4.3.1` and specifying:
    * `Helidon SE` for the flavor
    * `Quickstart` for the application type
    * `io.helidon.labs.apps` as the Maven `groupId`
    * `helidon-labs-apps-metrics-quickstart-se` as the Maven `artifactId`
    * `io.helidon.labs.apps.metrics.quickstart.se` as the package
    * defaults for other prompts

## Build and run the initial project (before any changes)
1. In a command window:
   ```shell
   mvn clean package
   java -jar target/helidon-labs-apps-metrics-quickstart-se.jar
   ```
2. In another command window run the following commands:
   ```shell
   curl http://localhost:8080/greet
   curl http://localhost:8080/observe/metrics | grep requests_count
   ```
   The first `curl` displays `{"message":"Hello World!"}`. The second displays the following output:
   ```list
   # HELP requests_count_total Each request (regardless of HTTP method) will increase this counter
   # TYPE requests_count_total counter
   requests_count_total{scope="vendor",} 2.0
   ```
   The Helidon-provided count is 2 because even requests to the `/observe/metrics` or other built-in Helidon endpoints contribute to the requests count.

   Run one more command:
   ```shell
   curl http://localhost:8080/observe/metrics
   ```
   The output includes numerous built-in Helidon system meters describing JVM behavior, including class loading data, GC, etc. The `pom.xml` file generated by `helidon init` contains a dependency on `io.helidon.metrics:helidon-metrics-system-meters` which provides these meters.

## Add the registration and use of a custom timer
Next, add a custom `Timer` to measure the time spent processing `GET` requests.

1. Declare a dependency on the Helidon metrics API artifact.

   Add the following lines to the `pom.xml` file:
   ```xml
   <dependency>
       <groupId>io.helidon.metrics</groupId>
       <artifactId>helidon-metrics-api</artifactId>
   </dependency>
   ```
   Your project would work without adding this because the API component is a transitive dependency, but it's good practice to explicitly declare any component your code uses directly.
2. Add code to declare, register, and update the custom `Timer`.

   Add to `GreetService.java`
    1. Class-level declaration of the `Timer` to register and update:
   ```java
    /*
    Timer for all "get greeting" invocations.
     */
    private Timer getsTimer;
   ```
    2. In the constructor which accepts a `Config` argument register the timer:
   ```java
        /*
        Create the timer to update on each get operation.
         */
        getsTimer = Metrics.globalRegistry().getOrCreate(Timer.builder("allGets")
           .description("All get operations"));
   ```
    3. In `getDefaultMessageHandler` replace the method body with this code to wrap the request handling so it is timed:
   ```java
        /*
        One way to time code.
         */
        getsTimer.record(() ->
            sendResponse(response, "World")
        );
   ```
    4. In `getMessageHandler` replace the method body with this code to record the time before processing the request, then process the request, then update the timer using the time difference:
   ```java
        String name = request.path().pathParameters().get("name");
        /*
        Another way to time code.
         */
        long startTime = System.nanoTime();
        sendResponse(response, name);
        getsTimer.record(Duration.ofNanos(System.nanoTime() - startTime));
   ```
   Notice the two different ways of updating the timer. Check the [Javadoc for Helidon's `Timer` type](https://helidon.io/docs/latest/apidocs/io.helidon.metrics.api/io/helidon/metrics/api/Timer.html)--including the `Timer.Sample` interface--to see all ways to update a timer. Use whichever is more convenient given the code you want to measure.
3. Stop, rebuild, and rerun the application.
    1. Stop the earlier run of the application if you have not already.
    2. Run the following commands in the original terminal window.
   ```shell
   maven clean package
   java -jar target/helidon-labs-apps-metrics-quickstart-se.jar
   ```
    4. Access the app and retrieve metrics, inspecting the output for the new custom timer just added.
        1. Run the following commands:
           ```shell
           curl http://localhost:8080/greet
           curl http://localhost:8080/observe/metrics | grep allGets
           ```
        2. Note the several lines of output for the new `allGets` timer (naturally, your values might be different):
            ```list
            # HELP allGets_seconds_max All get operations
            # TYPE allGets_seconds_max gauge
            allGets_seconds_max{scope="application",} 0.003731916
            # HELP allGets_seconds All get operations
            # TYPE allGets_seconds summary
            allGets_seconds{scope="application",quantile="0.5",} 0.003670016
            allGets_seconds{scope="application",quantile="0.75",} 0.003670016
            allGets_seconds{scope="application",quantile="0.95",} 0.003670016
            allGets_seconds{scope="application",quantile="0.98",} 0.003670016
            allGets_seconds{scope="application",quantile="0.99",} 0.003670016
            allGets_seconds{scope="application",quantile="0.999",} 0.003670016
            allGets_seconds_count{scope="application",} 1.0
            allGets_seconds_sum{scope="application",} 0.003731916   
            ```
        3. Wait a few minutes, then retrieve metrics again.
           ```shell
           curl http://localhost:8080/observe/metrics | grep allGets
           ```
           ```list
           # HELP allGets_seconds_max All get operations
           # TYPE allGets_seconds_max gauge
           allGets_seconds_max{scope="application",} 0.0
           # HELP allGets_seconds All get operations
           # TYPE allGets_seconds summary
           allGets_seconds{scope="application",quantile="0.5",} 0.0
           allGets_seconds{scope="application",quantile="0.75",} 0.0
           allGets_seconds{scope="application",quantile="0.95",} 0.0
           allGets_seconds{scope="application",quantile="0.98",} 0.0
           allGets_seconds{scope="application",quantile="0.99",} 0.0
           allGets_seconds{scope="application",quantile="0.999",} 0.0
           allGets_seconds_count{scope="application",} 1.0
           allGets_seconds_sum{scope="application",} 0.003731916
           ```
           Note that the `count` and `sum` still reflect the earlier access to the `/greet` endpoint, but the other statistics are zero. These value shows the time-window behavior of distribution summaries; Micrometer clears those values if no updates are applied to the meter in a certain period of time. See the discussion of the time window in the Micrometer [`Timer`](https://docs.micrometer.io/micrometer/reference/concepts/timers.html) documentation.

## Use Prometheus to view metrics
The Prometheus server is one of several backends which can retrieve metrics from a server and allow you to query and display them.

In a terminal window, `cd` to this project's top-level directory and start Prometheus wherever you downloaded it to.

```shell
cd this-project-directory
./path-to-prometheus/prometheus
```

Prometheus reads the `prometheus.yml` file from the current directory.

Use a browser to navigate to `localhost:9090`.

1. View the status of the scraped applications.

   Click on the "Status" drop-list at the top of the page and click on "Target health." The status page shows both the SE and MP demo apps. At least one should be running and displayed in green.
2. Click the "Prometheus" link in the upper left to return to the main query page.
3. Click on the "Graph" tab.
4. Click in the "Enter expression" field near the top and enter "all". The UI displays matching meter names. Click on "allGets_seconds_sum" and then the "Execute" button to the right to graph the accumulated total time spent responding to get requests.
5. In the query field change the meter name to "allGets_seconds" and click "Execute." The UI shows multiple lines, color-coded to each of the percentiles listed at the bottom of the UI.

   If you wait a moment, then click "Execute" again, you will see the values drop to zero, illustrating the time window behavior of distribution summaries (histograms).


